import { visit } from "unist-util-visit";

/**
 * Transform GFM footnotes into inline hover tooltips.
 *
 * Finds the `<section data-footnotes>` generated by remark-gfm,
 * builds a map of footnote content, replaces each `<sup>` footnote
 * ref with a tooltip span using the preceding word as trigger text,
 * then removes the footnotes section entirely.
 *
 * @param {import('hast').Root} tree
 */
export function processTooltips(tree) {
  // Step 1: Find the footnotes section
  let footnotesSection = null;
  let footnotesParent = null;
  let footnotesIndex = -1;

  visit(tree, "element", (node, index, parent) => {
    if (
      node.tagName === "section" &&
      "dataFootnotes" in (node.properties || {})
    ) {
      footnotesSection = node;
      footnotesParent = parent;
      footnotesIndex = index;
      return false; // stop visiting
    }
  });

  if (!footnotesSection) return;

  // Step 2: Build footnote content map from <ol><li> children
  const footnoteMap = buildFootnoteMap(footnotesSection);
  if (footnoteMap.size === 0) return;

  // Step 3: Replace footnote refs with tooltip spans
  replaceFootnoteRefs(tree, footnoteMap);

  // Step 4: Remove the footnotes section
  if (footnotesParent && footnotesIndex >= 0) {
    footnotesParent.children.splice(footnotesIndex, 1);
  }
}

/**
 * Walk the footnotes <section> and extract text content from each <li>.
 * @param {import('hast').Element} section
 * @returns {Map<string, string>} footnote key → text content
 */
function buildFootnoteMap(section) {
  const map = new Map();

  visit(section, "element", (node) => {
    if (node.tagName !== "li") return;

    const id = node.properties?.id;
    if (typeof id !== "string" || !id.startsWith("user-content-fn-")) return;

    const key = id.replace("user-content-fn-", "");
    const text = extractFootnoteText(node);
    if (text) {
      map.set(key, text);
    }
  });

  return map;
}

/**
 * Extract plain text from a footnote <li>, stripping the backref link.
 * @param {import('hast').Element} li
 * @returns {string}
 */
function extractFootnoteText(li) {
  const parts = [];

  visit(li, (node, _index, parent) => {
    // Skip backref links
    if (
      node.type === "element" &&
      node.tagName === "a" &&
      "dataFootnoteBackref" in (node.properties || {})
    ) {
      return "skip";
    }
    if (node.type === "text" && parent?.tagName !== "a") {
      // Only collect text that isn't inside the backref anchor
      // But we need to handle text inside <p> that's a sibling of <a>
      parts.push(node.value);
    }
  });

  return parts.join("").trim();
}

/**
 * Find all footnote ref <sup> elements and replace them with tooltip spans.
 * Extracts the preceding word as trigger text.
 *
 * Processes refs right-to-left within each parent so earlier indices stay
 * valid after each splice.
 *
 * @param {import('hast').Root} tree
 * @param {Map<string, string>} footnoteMap
 */
function replaceFootnoteRefs(tree, footnoteMap) {
  visit(tree, "element", (node) => {
    if (!node.children) return;

    for (let i = node.children.length - 1; i >= 0; i--) {
      const child = node.children[i];

      if (!isFootnoteRef(child)) continue;

      // Extract footnote key from the <a> inside <sup>
      const anchor = child.children.find(
        (c) =>
          c.type === "element" &&
          c.tagName === "a" &&
          "dataFootnoteRef" in (c.properties || {})
      );
      if (!anchor) continue;

      const href = anchor.properties?.href;
      if (typeof href !== "string") continue;

      const key = href.replace("#user-content-fn-", "");
      const content = footnoteMap.get(key);
      if (!content) continue;

      // Build tooltip span
      const tooltip = buildTooltipNode(
        extractTriggerWord(node.children, i, key),
        content
      );

      // Splice: remove <sup>, insert tooltip in place.
      // extractTriggerWord already trimmed the preceding text node in-place.
      node.children.splice(i, 1, tooltip);
    }
  });
}

/**
 * Build a tooltip HAST element.
 * @param {string} trigger
 * @param {string} content
 * @returns {import('hast').Element}
 */
function buildTooltipNode(trigger, content) {
  return {
    type: "element",
    tagName: "span",
    properties: { className: ["gfm-tooltip"] },
    children: [
      {
        type: "element",
        tagName: "span",
        properties: { className: ["gfm-tooltip-trigger"], tabIndex: 0 },
        children: [{ type: "text", value: trigger }],
      },
      {
        type: "element",
        tagName: "span",
        properties: {
          className: ["gfm-tooltip-content"],
          role: "tooltip",
        },
        children: [{ type: "text", value: content }],
      },
    ],
  };
}

/**
 * Check if a node is a footnote ref <sup>.
 * @param {import('hast').Node} node
 * @returns {boolean}
 */
function isFootnoteRef(node) {
  if (node.type !== "element" || node.tagName !== "sup") return false;
  return node.children?.some(
    (c) =>
      c.type === "element" &&
      c.tagName === "a" &&
      "dataFootnoteRef" in (c.properties || {})
  );
}

/**
 * Extract the last word from the nearest preceding text node as trigger text.
 * Mutates the text node in-place (trims the word off the end) so that the
 * caller can simply splice the <sup> without rebuilding the children array.
 *
 * @param {import('hast').Node[]} children
 * @param {number} supIndex - index of the <sup> element
 * @param {string} fallback - footnote key to use as fallback
 * @returns {string} the trigger word
 */
function extractTriggerWord(children, supIndex, fallback) {
  for (let j = supIndex - 1; j >= 0; j--) {
    const prev = children[j];
    if (prev.type !== "text") continue;

    const text = prev.value;
    const lastSpace = text.lastIndexOf(" ");

    if (lastSpace >= 0) {
      const trigger = text.slice(lastSpace + 1);
      prev.value = text.slice(0, lastSpace + 1);
      return trigger;
    }

    // Entire text node is one word — consume it entirely and remove the node
    children.splice(j, 1);
    return text;
  }

  return fallback;
}
